ns {
	global init, hydrate

	Status = AbstractProcess::Status::Status

	type Execution(AbstractProcess::Process)
	type ExecutionStage(AbstractProcess::Process)
	type ExecutionStageAction(AbstractProcess::Process)  # TODO: subtypes?

	F init(esa:ExecutionStageAction, action:Hash) {
		super(esa)
		esa.name = action.name
		esa.status = AbstractProcess::Status::NotStarted()
	}

	F hydrate(esa:ExecutionStageAction) warn("hydrate(${esa.Type().name}) is not implemented yet")

	section "CodeBuildPhase" {
		type CodeBuildPhase(AbstractProcess::Process)

		F init(c:CodeBuildPhase, phase:Hash) {
			super(c)
			c.name = phase.phaseType
			c.status = Status(phase.phaseStatus)
			# HERE # c.output.push
			# statusCode message # temp: making a string out of structured data, generally a bad idea
			phase.get('contexts', []).each(F(context) {
				text = context.statusCode +? ' ' +? context.message
				not(text) returns
				c.output.push(text)
			})
		}

		F hydrate(c:CodeBuildPhase) {
		}

	}

	section "CodeBuild action" {
		type CodeBuildExecutionStageAction(ExecutionStageAction)

		F ExecutionStageAction(action:Hash) {
			guard action =~ {
				'actionTypeId': {
					'owner': 'AWS'
					'provider': 'CodeBuild'
				}
			}
			CodeBuildExecutionStageAction(action)
		}

		F hydrate(c:CodeBuildExecutionStageAction) c::{
			c.status.text = c.action_execution.output.executionResult.externalExecutionSummary
			eid = c.action_execution.output.executionResult.externalExecutionId
			build = ``aws codebuild batch-get-builds --ids ${eid}``.the_one()
			# echo("BUILD $build")
			# Filter below is needed for {"phaseType": "COMPLETED", ...} phase
			c.sub = build.phases.filter({'phaseStatus': Str}).map(CodeBuildPhase)

			phase_name_to_phase = Hash(c.sub.name, c.sub)

			# logs: {groupName=/aws/codebuild/..., streamName=..., deepLink=..., cloudWatchLogsArn=}
			events = ``aws logs get-log-events --log-group-name ${build.logs.groupName} --log-stream-name ${build.logs.streamName} --start-from-head``

			phase = null
			events.message.each(F(message) {
				message .= trim()
				if m = message ~ /Container.*(Entering phase|Phase is) (.*)$/ {
					phase = m[2]
					return
				}
				if message ~ /Container.*Phase complete:/ {
					phase = null
					return
				}
				if message ~ /Container.*Phase context status code/ {
					return
				}
				if not(phase) {
					c.output.push(message)
					return
				}
				phase_name_to_phase[phase].output.push(message)
			})


		}
	}

	# Info from https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-stage-executions :
	# "Valid statuses for stages are InProgress, Stopping, Stopped, Succeeded, and Failed. You can retry a failed stage unless the failed stage is not retryable. For more information, see StageExecution."
	# TODO: support "latest" execution
	# TODO: un-pollute AbstractProcess::Process fields (pipelineName and pipelineExecutionId can not be at top level, polluting AbstractProcess::Process)
	F init(e:Execution, pipelineName:Str, pipelineExecutionId:Str) {
		super(e)
		init(args())
		# TODO: something better
		# TODO: how to reference the thing that is corresponding to binary (in our case pipeline + version)?
		e.name = "${pipelineName}/${pipelineExecutionId}"
	}

	F hydrate(e:Execution) e::{

		aes = ``log: aws codepipeline list-action-executions --pipeline-name ${e.pipelineName} --filter "pipelineExecutionId=${e.pipelineExecutionId}"``
		pipeline_version = aes.pipelineVersion.uniq().the_one()

		pipeline = ``log: aws codepipeline get-pipeline --name ${e.pipelineName} --pipeline-version ${pipeline_version}``
		# echo(inspect(pipeline))

		section "Processes that should have happened, from pipeline definition" {
			stages_actions = {}  # stage name + '::' + action name -> ExecutionStageAction
			e.sub = pipeline.stages.map(F(stage) {
				ExecutionStage().set(
					not_status = AbstractProcess::Status::NotStarted()
					name = stage.name
					sub = stage.actions.map(F(action) {
						ExecutionStageAction(action)::{
							k = "${stage.name}::${action.name}"
							assert(k not in stages_actions)
							stages_actions[k] = A
						}
					})
				)
			})
		}

		section "Update processes with info from list-action-executions" {
			aes.each(F(ae) {
				stages_actions["${ae.stageName}::${ae.actionName}"]::{
					A.status = Status(ae.status)
					A.action_execution = ae  # TODO: un-pollute AbstractProcess::Process fields
				}
			})
		}

		# TODO: flexible logic for what to hydrate
		stages_actions.values().filter({'status': AbstractProcess::Status::Failed}).each(hydrate)

		e.compute_status()

	}

	F executions(pipelineName:Str) {
		``aws codepipeline list-pipeline-executions --pipeline-name ${pipelineName}``.map(X.rejectk(AnyOf(%[sourceRevisions trigger])))
	}

	F main(pipelineName:Str) {
		executions(pipelineName).filter({'status': 'Failed'}).limit(5).each(F(e) {
			log("test()ing Execution $e")
			ee = Execution(pipelineName, e.pipelineExecutionId).hydrate()
			echo(inspect(ee))
		})
	}
}