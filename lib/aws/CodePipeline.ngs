ns {
	global init, hydrate

	Status = AbstractProcess::Status::Status

	type Execution(AbstractProcess::Process)
	type ExecutionStage(AbstractProcess::Process)
	type ExecutionStageAction(AbstractProcess::Process)  # TODO: subtypes?

	F init(esa:ExecutionStageAction, action:Hash) {
		super(esa)
		esa.name = action.name
		esa.status = AbstractProcess::Status::NotStarted()
	}

	F hydrate(esa:ExecutionStageAction) warn("hydrate(${esa.Type().name}) is not implemented yet")

	section "CodeBuildPhase" {
		type CodeBuildPhase(AbstractProcess::Process)

		F init(c:CodeBuildPhase, phase:Hash) {
			super(c)
			c.name = phase.phaseType
			c.status = Status(phase.phaseStatus)
			c.start = phase.Box('startTime').map(Time).get(null)
			c.end = phase.Box('endTime').map(Time).get(null)
			# HERE # c.output.push
			# statusCode message # temp: making a string out of structured data, generally a bad idea
			phase.get('contexts', []).each(F(context) {
				text = context.statusCode +? ' ' +? context.message
				not(text) returns
				c.output.push(text)
			})
		}

		F hydrate(c:CodeBuildPhase) {
		}

	}

	section "CodeBuild action" {
		type CodeBuildExecutionStageAction(ExecutionStageAction)

		F ExecutionStageAction(action:Hash) {
			guard action =~ {
				'actionTypeId': {
					'owner': 'AWS'
					'provider': 'CodeBuild'
				}
			}
			CodeBuildExecutionStageAction(action)
		}

		F hydrate(c:CodeBuildExecutionStageAction) c::{
			eid = c.action_execution.output.executionResult.externalExecutionId
			c.sub.push(require('aws/CodeBuild.ngs')::Build(eid).hydrate())
		}
	}

	section "CloudFormation action" {
		type CloudFormationStageAction(ExecutionStageAction)

		F ExecutionStageAction(action:Hash) {
			guard action =~ {
				'actionTypeId': {
					'owner': 'AWS'
					'provider': 'CloudFormation'
				}
			}
			CloudFormationStageAction(action)
		}

		F hydrate(c:CloudFormationStageAction) c::{
			throw NotImplemented("hydrate() not implemented for ${c}")
			c
		}

		F hydrate(c:CloudFormationStageAction) {
			input = c.action_execution.input
			conf = input.configuration
			guard conf.ActionMode == 'CHANGE_SET_REPLACE'
			# c.status = require('aws/CloudFormation.ngs')::Status(c.action_execution.)
			c.status = Status(c.action_execution.status)
			c.action_execution.output.inspect().each({ c.output.push(A) })
			c.output.push("PT10")
			# die("$c")
			c
		}

		F hydrate(c:CloudFormationStageAction) {
			input = c.action_execution.input
			conf = input.configuration
			guard conf.ActionMode == 'CHANGE_SET_EXECUTE'
			# exit("AA ${stack_arn} ${c.action_execution}")

			# output={outputArtifacts=[], executionResult={externalExecutionId=stack/detail?stackId=arn:aws:cloudformation:eu-central-1:704328435781:stack/demo-session-manager-cdk-app/05c9e9b0-7ef5-11ee-a85c-0a0c2a8fe1e7

			# It looks like there is no way to access history of change sets, operating based on time of events
			# https://stackoverflow.com/questions/41841083/cloudformation-vieweing-inactive-deleted-change-sets
			stack_arn = c.action_execution.output.executionResult.externalExecutionId.split('stackId=')[1]
			c.sub.push(require('aws/CloudFormation.ngs')::StackOperation(stack_arn, Time(c.action_execution.startTime)).hydrate())
			c
		}
	}

	# Info from https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-stage-executions :
	# "Valid statuses for stages are InProgress, Stopping, Stopped, Succeeded, and Failed. You can retry a failed stage unless the failed stage is not retryable. For more information, see StageExecution."
	# TODO: support "latest" execution
	# TODO: un-pollute AbstractProcess::Process fields (pipelineName and pipelineExecutionId can not be at top level, polluting AbstractProcess::Process)
	F init(e:Execution, pipelineName:Str, pipelineExecutionId:Str) {
		super(e)
		init(args())
		# TODO: something better
		# TODO: how to reference the thing that is corresponding to binary (in our case pipeline + version)?
		e.name = "${pipelineName}/${pipelineExecutionId}"
	}

	F hydrate(e:Execution) e::{

		aes = ``log: aws codepipeline list-action-executions --pipeline-name ${e.pipelineName} --filter "pipelineExecutionId=${e.pipelineExecutionId}"``
		pipeline_version = aes.pipelineVersion.uniq().the_one()

		pipeline = ``log: aws codepipeline get-pipeline --name ${e.pipelineName} --pipeline-version ${pipeline_version}``
		# echo(inspect(pipeline))

		section "Processes that should have happened, from pipeline definition" {
			stages_actions = {}  # stage name + '::' + action name -> ExecutionStageAction
			e.sub = pipeline.stages.map(F(stage) {
				ExecutionStage().set(
					not_status = AbstractProcess::Status::NotStarted()
					name = stage.name
					sub = stage.actions.map(F(action) {
						ExecutionStageAction(action)::{
							k = "${stage.name}::${action.name}"
							assert(k not in stages_actions)
							stages_actions[k] = A
						}
					})
				)
			})
		}

		section "Update processes with info from list-action-executions" {
			aes.each(F(ae) {
				stages_actions["${ae.stageName}::${ae.actionName}"]::{
					A.status = Status(ae.status)
					A.action_execution = ae  # TODO: un-pollute AbstractProcess::Process fields
				}
			})
		}

		# TODO: flexible logic for what to hydrate
		stages_actions.values().filter({'status': AbstractProcess::Status::Failed}).each(hydrate)

		e.compute_status()

	}

	F executions(pipelineName:Str) {
		``aws codepipeline list-pipeline-executions --pipeline-name ${pipelineName}``.map(X.rejectk(AnyOf(%[sourceRevisions trigger])))
	}

	F main(pipelineName:Str) {
		executions(pipelineName).filter({'status': 'Failed'}).limit(5).each(F(e) {
			log("test()ing Execution $e")
			# TODO: .start and .end
			ee = Execution(pipelineName, e.pipelineExecutionId).hydrate()
			echo(inspect(ee))
		})
	}
}