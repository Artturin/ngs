ns {
	# WIP
	# Warning: low quality, hacky code

	global id
	doc Warning! Not sure about correctness!
	F id(t:Type) {
		m = t.meta()
		has_ns = m =~ {'ns': Namespace}
		not(has_ns) returns "ngs:type:${t.name}"
		if m.ns.meta().has(JsonData) {
			# Maybe :: separator here is not a good idea
			return "ngs:type:${m.ns.meta()[JsonData].ns}::${t.name}"
		}
		throw NotImplemented("id() for types in namespaces (without .meta()[JsonData].ns} is not implemented yet").set('type', t)
	}

	doc To Do: better naming
	type InteractiveObject

	doc Can't use JsonData for anything in this namespace, it clashes with the multimethod
	F id(t:Type) {
		guard t === InteractiveObject
		'ngs:type:ui::InteractiveObject'
	}

	F _json_data_fields(x, fields:Arr) {
		{
			'type': id(x.Type())
			'fields': fields.Hash({ JsonData(x.(A)) })
		}
	}

	F _json_data_fields(x) {
		{
			'type': id(x.Type())
			'fields': x.Hash().mapv(JsonData)
		}
	}

	F JsonData(x) throw NotImplemented("JsonData() for type ${x.Type()} is not implemented yet").set(val=x)

	section "JsonData - scalars" {
		F JsonData(x:AnyOf(Num, Str, Bool, Null)) {
			{ 'type': id(x.Type()), 'value': x }
		}
		F JsonData(p:Path) { 'type': id(p.Type()), 'value': p.path }
	}

	section "JsonData - lists" {
		F JsonData(a:AnyOf(Arr, ArrLike)) {
			{ 'type': id(a.Type()), 'items': a.map(JsonData) }
		}
	}

	section "JsonData - maps" {
		F JsonData(h:AnyOf(Hash, HashLike)) {
			{
				'type': id(h.Type())
				'items': h.map(F(k, v) [k.JsonData(), v.JsonData()])
			}
		}
	}

	section "JsonData - table" {
		Table2.meta()[JsonData] = {'ns': 'Table2'}
		F JsonData(t:Table2::Table) {
			{
				'type': id(t.Type())
				'name': t.name.JsonData()
				'columns_names': t.cols_enum.keys().JsonData()
				'rows': t.rows.JsonData()
			}
		}
	}

	F JsonData(c:Command) c._json_data_fields(%[argv])

	F JsonData(p:Process) p._json_data_fields(%[command executable pid exit_code exit_signal stdout stderr])

	F JsonData(f:Fun) f.Str().JsonData()

	doc Incorrect, should pass the whole pipeline
	F JsonData(p:ProcessesPipeline) p.processes[-1].JsonData()
	F JsonData(p:ProcessesPipeline) {
		guard p.processes.len() > 1
		throw NotImplemented()
	}

	F JsonData(rd:ResDef) {
		warn("Unexpected use of JsonData(ResDef)")
		resources = rd.find().resources
		Table2::Table(resources.props).JsonData()
	}
	F JsonData(r:Res) r.Hash().without('def').JsonData().set(type=id(r.Type()))

	F JsonData(ps:AbstractProcess::Status::Status) ps._json_data_fields(%[text])

	section "InteractiveObject" {
		# TODO: Send context so that interaction could be seen as part of the bigger picture
		F JsonData(i:InteractiveObject) i._json_data_fields(%[type id text default_action])
	}

	section "AWS2" {
		# TODO: generalize
		AWS2.meta()[JsonData] = {'ns': 'AWS2'}
	}

	section "Process Status" {
		AbstractProcess::Status.meta()[JsonData] = {'ns': 'ProcessStatus'}
	}

	section "aws/*.ngs" {
		_cp = require("aws/CodePipeline.ngs")
		# TODO: factor out
		_cp.meta()[JsonData] = {'ns': 'CodePipeline'}

		F JsonData(saf:_cp::SendAllFields) saf._json_data_fields()

		F JsonData(p:_cp::Pipeline) {
			ui::InteractiveObject().set(
				type = 'AWS::CodePipeline::Pipeline'
				id = p.name
				text = p.name
				default_action = 'View CodePipeline'
			).JsonData()
		}
	}
}
