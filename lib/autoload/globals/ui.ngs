ns {
	# WIP
	global init, JsonData

	# TODO:
	# * Recreate previous version but cleanly
	# * Move transformation to table from shell.ngs to this file
	# * Add row/object-fields semantics
	# * Consider add nested context to render()
	# * UI action should have
	#	* Reference to the original command and the output
	#   * ID of the object
	#   * Action name

	type Element()

		type Screen(Element)
		type Object(Element)

		type Scalar(Element)
		type Table(Element)
			type Columns(Element)
			type Column(Element)
			type Rows(Element)
			type Row(Element)
		type Properties(Element)
		type List(Element)
		type ProcessStatus(Element)
		type Progress(Element)

	F raw(h:Hash) h + {'$type': '$raw'}

	F init(e:Element, children:Arr) {
		# assert(children, Repeat(Element))
		children.each({ assert(A, Element, "All children of Element must be of type Element") })
		# echo("init(${e.Type().name}, Arr)")
		init(args())
	}
	# TODO: serialization design
	F JsonData(e:Element) {
		# Note: all Element subtypes need to reside in this namespace
		#       if they don't, there could be name collisions
		{'$type': e.Type().name} + e.Hash().JsonData()
	}

	F JsonData(p:Properties) {
		{'$type': p.Type().name} + p.Hash().JsonData()::{A.props = {'$type': 'Hash'} + A.props}
	}

	F init(s:Scalar, value) init(args())
	F init(c:Column, name:Str) init(args())
	F init(p:Properties, props:Hash) init(args())
	F init(p:ProcessStatus, name:Str, text:Str) init(args())  # TODO: improve + add semantics
	F init(p:Progress, step:Int, total_steps:Int) init(args())


	F Element(x:AnyOf(Num, Str, Bool, Null)) Scalar(x)
	F Element(a:AnyOf(Arr, ArrLike)) List(a.map(Element))

	# TODO: improve heuristics of detection when to render to table
	F Element(a:Arr) {
		guard a
		guard all(a, Hash)
		t = Table2::Table(a)

		Table().set(
			columns = t.cols_enum.keys().map(Column).Columns()
			rows = t.rows.map(F(row) {
				Row(row.map(Element)) # map each cell
			}).Rows()
		)
	}

	F keys_are_strings(h) h.keys().all(Str)
	F Element(h:AnyOf(Hash, HashLike)) Properties(h.assert(keys_are_strings, "Element(Hash) - keys must be strings").mapv(Element))


	# TODO: Fix later. It's semantically incorrect to display path as just a string
	F Element(p:Path) Scalar(p.path)

	section "ProcessesPipeline" {
		# TODO: Use AbstractProcess
		F Element(pp:ProcessesPipeline) {
			processes = pp.processes
			guard processes
			p = processes[-1]
			{ p.stdout.decode({'process': p}) }.Result().dflt({
				error("In shell.ngs, trying to decode:")
				print_exception(A.val)
				# throw InvalidArgument("Element() could not decode process output").set(process=p)
				p.stdout  # TODO: maybe split into lines
			}).get().Element()
		}
	}

	section "AWS" {
		# TODO: Move whatever possible from CodePipeline.ngs to AbstractProcess.ngs
		_cp = require("aws/CodePipeline.ngs")

		F Element(s:AbstractProcess::Status::Status) ProcessStatus(s.Type().name, s.text)

		# TODO: .total_steps might not be known
		F Element(p:_cp::Progress) Progress(p.step, p.total_steps)

		# WIP
		F Element(cp:_cp::Pipeline) {
			Object([Element(Str(cp))])::{
				A.('$id') = raw({
					"type": "AWS::CodePipeline::Pipeline"
					"id": cp.name
					"blah-str": "s123"
					"blah-num": 123
				})
			}
		}

		# Later
		F Element(r:_cp::Revision) Element(Str(r))
		F Element(s:_cp::Source) Element(Str(s))
		F Element(a:_cp::Action) Element(Str(a))
	}

	# ngs -ppj 'require("aws/CodePipeline.ngs")::pipelines::list().(ui::Element)'
	# ngs -ppj '$(ls).(ui::Element)'
}
