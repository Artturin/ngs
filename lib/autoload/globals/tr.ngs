ns {
	# EXPERIMENTAL!
	# For examples, see tests in the end of this file

	global tr, init, (=~), descend, skip, Str

	DESCENDABLE1 = AllOf(Eachable1, X !~ Int, X !~ Str)

	# TODO: Provide metadata such as "DESCENDABLE" name so that
	# it will be visisble through Str() and/or inspect(). How?
	DESCENDABLE = AnyOf(DESCENDABLE1, Eachable2)

	global TrContext
	type TrContext(MatchContext)
		F init(ctx:TrContext, root, transformation) {
			super(ctx, root)
			ctx._transformation = transformation
			ctx._cur = null # current item being processed by tr(), used by descend(TrContext)
			ctx._cmd = null
		}

	doc Implementation details of different operations provided by TrContext
	type TrCommand

		doc Implementation detail of skip(TrContext)
		type TrSkip(TrCommand)


	F init(cmd:TrCommand, x, ctx:TrContext) {
		n = cmd.typeof().name
		throw InvalidArgument("Use ${n}(...) instead of ${n}")
	}

	F _unified_each(e:Eachable1, cb:Fun) e.each_idx_val(cb)
	F _unified_each(e:Eachable2, cb:Fun) e.each(cb)

	F _unified_push(e:Eachable1, _idx:Int, val) e.push(val)
	F _unified_push(e:Eachable2, key, val) e[key] = val

	F _each(tc:TrContext, cb:Fun) {
		tc.deeper({
			tc._cur._unified_each(F(idx_or_key, val) {
				tc.set_last_path_element(idx_or_key)
				debug("tr", {"descend path=${tc._path}"})
				cb(idx_or_key, val)
			})
		})
	}

	F _default_descend_transformation(tc:TrContext, idx_or_key) tc._transformation

	F descend(tc:TrContext, transformation_cb:Fun=_default_descend_transformation) {
		tc._cur !~ DESCENDABLE throws InvalidArgument("Attempted to descend on non-descendable: ${tc._cur} at path ${tc._path}")

		debug("tr", {"descend::start ${tc._path}"})
		t = typeof(tc._cur)
		ret = t()  # XXX: Assumption about existence of the constructor
		tc._each(F(idx_or_key, val) {
			t = tr(val, transformation_cb(tc, idx_or_key), tc)
			debug("tr", {"descend value from tr() - ${t}"})
			### TODO: Handle TrNoMatch ###
			ematch t {
				Lit _unified_push(ret, idx_or_key, t.val)
				TrSkip null # do nothing
			}
		})
		ret
	}

	F skip(tc:TrContext) tc._cmd = TrSkip()

	doc Implementation detail of tr()
	type TrNoMatch

	doc Implementation detail of tr()
	type TopLevelRules(ArrLike)

	F tr(x, pattern, tc:TrContext) {
		x =~ pattern returns Lit(x)
		TrNoMatch()
	}

	F tr(x, a:Arr, tc:TrContext) {
		debug("tr", "tr(x, Arr, TrContext) - before guards")
		x !~ DESCENDABLE1 returns TrNoMatch()
		l = x.len()
		l != a.len() returns TrNoMatch()
		debug("tr", "tr(x, Arr, TrContext) - after guards")

		tc.deeper({'_cur': x, '_cmd': null}, {
			ret = tc.descend(F(tc:TrContext, idx_or_key) a[idx_or_key])
			Lit(ret)
		})
	}


	F tr(x, pa:PatternAction, tc:TrContext) {

		debug("tr", {"tr(x, PatternAction, TrContext) pa=${pa} tc=${tc}"})

		if (=~)(x, pa.pattern, tc) {
			return tc.deeper({'_cur': x, '_cmd': null}, {
				ret = pa::action(x, tc)
				tc._cmd is not Null returns tc._cmd
				Lit(ret)
			})
		}
		TrNoMatch()
	}

	F tr(x, transformation:TopLevelRules, tc:TrContext) block b {
		debug("tr", "tr(x, TopLevelRules, TrContext) transformation=${transformation}")
		transformation.each(F(t) {
			result = tr(x, t, tc)
			if result is not TrNoMatch	{
				debug("tr", "tr(x, TopLevelRules, TrContext) returning ${result}")
				b.return(result)
			}
		})
		throw InvalidArgument("None of the transformations matched").set(transformation=transformation)
	}

	doc Public API of the transofmration/tr() experimental facility
	F tr(x, transformation) {
		warn("Using experimental feature - tr()")
		t = transformation.ensure(TopLevelRules)
		# Default rules, appended automatically at the bottom:
		#   * recurse into Eachable1 and Eachable2
		#   * whatever does not match, returned as is
		t += TopLevelRules([
			DESCENDABLE -> descend(Y)
			Any -> { A }
		])
		tc = TrContext(x, t)
		result = tr(x, t, tc)
		# TODO: better exception
		assert(tc, {'_cmd': Null}, "Transformation failed, top level must return a value")

		# Fails with: tr; [10,20].tr([[Int, Int] -> Y.skip()])
		# But shuold fail at the assertion above
		assert(result, Lit, "Transformation must return literal (type Lit), not ${result}")

		result.val
	}

	TEST [1,2,3].tr(Int -> (X+1)) == [2,3,4]
	TEST {"a": [1,2,3]}.tr(Int -> (X+1)) == {"a": [2,3,4]}
	TEST tr; tr([1,2,[3,4]], Arr -> { ["start"] + descend(B) + ["end"] } ) == ["start", 1, 2, ["start", 3, 4, "end"], "end"]
	TEST tr; {"a": 1, "b": "x"}.tr(Str -> Y.skip()) == {"a": 1}
	TEST tr; [{"a": 1, "b": "x"}].tr([ Str -> Y.skip(), Int -> (X+1), Arr -> {["start", *descend(B)]} ]) == ["start", {"a": 2}]
	TEST [10,20].tr([[Int, Int -> (X+1)]]) == [10, 21]
	#FAILS# TEST tr; [1, [10,20]].tr([[Int, Int -> Y.skip()]])
}
