ns {
	# EXPERIMENTAL!
	# For examples, see tests in the end of this file

	global tr, init, (=~), descend

	global TrContext
	type TrContext(MatchContext)
		F init(ctx:TrContext, root, transformation) {
			super(ctx, root)
			ctx._transformation = transformation
			ctx._cur = null # current item being processed by tr(), used by descend(TrContext)
		}

	global TrActionResult
	type TrActionResult
		Lit.inherit(TrActionResult)

	global TrCommand
	type TrCommand(TrActionResult)

		global TrSkip
		type TrSkip(TrCommand)

		global TrNoMatch
		type TrNoMatch(TrCommand)

	F init(cmd:TrCommand, x, ctx:TrContext) {
		n = cmd.typeof().name
		throw InvalidArgument("Use ${n}(...) instead of ${n}")
	}

	F TrActionResult(x) Lit(x)
	F TrActionResult(x:TrActionResult) x

	F descend(tc:TrContext, my_each:Fun, my_result:Fun) {
		debug("tr", {"descend::start ${tc._path}"})
		t = typeof(tc._cur)
		ret = t()  # XXX: Assumption about existence of the constructor
		tc.deeper({
			tc._cur.my_each(F(idx_or_key, val) {
				debug("tr", {"${tc._path} descend-tr each(${idx_or_key},${val})"})
				t = tr(val, tc._transformation, tc.set_last_path_element(idx_or_key))
				ematch t {
					Lit my_result(ret, idx_or_key, t.val)
					TrSkip null # do nothing
				}
			})
		})
		ret
	}

	F descend(tc:TrContext) {
		throw InvalidArgument("Attempted to descend on non-descendable: ${tc._cur} at path ${tc._path}")
	}

	F descend(tc:TrContext) {
		guard tc._cur is Eachable1
		guard tc._cur !~ AnyOf(Int, Str)
		descend(tc, each_idx_val, F(ret, idx, val) ret.push(val))
	}

	F descend(tc:TrContext) {
		guard tc._cur is Eachable2
		descend(tc, each, F(ret, key, val) ret[key] = val)
	}

	F tr(x, pa:PatternAction, tc:TrContext) {

		debug("tr", {"x:Any - ${x}"})

		if (=~)(x, pa.pattern, tc) {
			pa.action is TrCommand returns pa.action
			return tc.deeper({'_cur': x}, { pa::action(x, tc).TrActionResult() })
		}
		TrNoMatch()
	}

	F tr(x, transformation:Arr, tc:TrContext) block b {
		transformation.each(F(t) {
			result = tr(x, t, tc)
			if result is not TrNoMatch	{
				b.return(result)
			}
		})
		# TODO: Throw an error?
	}

	F tr(x, transformation) {
		warn("Using experimental feature - tr()")
		t = transformation.ensure(Arr)
		# Default rules at the bottom:
		#   * recurse into Eachable1 and Eachable2
		#   * whatever does not match, returned as is
		t += [
			AllOf(Eachable1, {A !~ AnyOf(Int, Str)}) -> descend(Y)
			Eachable2 -> descend(Y)
			Any -> { A }
		]
		tc = TrContext(x, t)
		result = tr(x, t, tc)
		assert(result, Lit, "Transformation failed, top level must return a value")
		result.val
	}

	TEST [1,2,3].tr(Int -> (X+1)) == [2,3,4]
	TEST {"a": [1,2,3]}.tr(Int -> (X+1)) == {"a": [2,3,4]}
	TEST tr; tr([1,2,[3,4]], Arr -> { ["start"] + descend(B) + ["end"] } ) == ["start", 1, 2, ["start", 3, 4, "end"], "end"]

}
