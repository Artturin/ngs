ns {
	# EXPERIMENTAL!

	global tr, init, (=~)

	# Examples:
	# tr; tr([1,2,[3,4]], TrAfter(Arr) -> { ["start"] + A + ["end"] } )
	# tr; {"some": "resource", "extension": [{"url": "x", "something": "y"}]}.tr({"url": "x"} -> TrSkip()).tr([] -> TrSkip())

	global TrContext
	type TrContext(MatchContext)

	global TrCommand
	type TrCommand

		global TrSkip
		type TrSkip(TrCommand)

		# Just checking. Not sure it's needed.
		# tr; ["a", 1].tr(Int -> TrSplice([3,4]))  # ["a", 3, 4]
		global TrSplice
		type TrSplice(TrCommand)

		F init(s:TrSplice, val) { s.val = val }

	# Open issue: the match is on the output or the original?
	# Temp decision: on the output
	global TrAfter
	type TrAfter()
		F init(ta:TrAfter) throw InvalidArgument("init(TrAfter) - missing the pattern argument")
		F init(ta:TrAfter, pattern) ta.pattern = pattern
		F =~(x, ta:TrAfter, _tc:TrContext) false

	F init(cmd:TrCommand, x, ctx:TrContext) {
		n = cmd.typeof().name
		throw InvalidArgument("Use ${n}(...) instead of ${n}")
	}

	F lit_or_cmd(x) Lit(x)
	F lit_or_cmd(x:TrCommand) x

	F tr(x, pa:PatternAction, tc:TrContext) {

		debug("tr", {"x:Any - ${x}"})

		if (=~)(x, pa.pattern, tc) {
			pa.action is TrCommand returns pa.action
			return pa::action(x, tc).lit_or_cmd()
		}
		Lit(x)
	}

	F tr(x:Eachable, pa:PatternAction, tc:TrContext, my_each:Fun, my_result:Fun) {

		debug("tr", {"x:Eachable - ${x}"})

		if (=~)(x, pa.pattern, tc) {
			pa.action is TrCommand returns pa.action  # not sure
			return pa::action(x, tc).lit_or_cmd()
		}

		t = typeof(x)
		ret = t()  # XXX: Assumption about existence of the constructor
		tc.deeper({
			x.my_each(F(idx_or_key, val) {
				debug("tr", {"each(${idx_or_key},${val}}"})
				t = tr(val, pa, tc.set_last_path_element(idx_or_key))
				ematch t {
					Lit my_result(ret, idx_or_key, t.val)
					TrSplice {
						t.val.each(my_result(ret, idx_or_key, X))
					}
					TrSkip null # do nothing
				}
			})
		})

		# Where else TrAfter should be?
		if pa.pattern is TrAfter {
			if (=~)(ret, pa.pattern.pattern, tc) {
				return pa::action(ret, tc).lit_or_cmd()
			}
		}

		Lit(ret)
	}

	F tr(x:Eachable1, pa:PatternAction, tc:TrContext) {
		guard x !~ AnyOf(Int, Str)
		tr(x, pa, tc, each_idx_val, F(ret, idx, val) ret.push(val))
	}

	F tr(x:Eachable2, pa:PatternAction, tc:TrContext) {
		tr(x, pa, tc, each, F(ret, key, val) ret[key] = val)
	}


	F tr(x, transformation) {
		warn("Using experimental feature - tr()")
		tc = TrContext().set(_root=x, transformation=transformation)
		result = tr(x, transformation, tc)
		assert(result, Lit, "Transformation failed, top level must return a value")
		result.val
	}

	TEST [1,2,3].tr(Int -> (X+1)) == [2,3,4]
	TEST {"a": [1,2,3]}.tr(Int -> (X+1)) == {"a": [2,3,4]}
	TEST tr; tr([1,2,[3,4]], TrAfter(Arr) -> { ["start"] + A + ["end"] } ) == ["start", 1, 2, ["start", 3, 4, "end"], "end"]

}
