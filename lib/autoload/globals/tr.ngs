ns {
	global tr, init

	type TrContext(MatchContext)

	F tr(x, pa:PatternAction, tc:TrContext) {
		if (=~)(x, pa.pattern, tc) {
			return pa::action(x, tc).FullBox()
		}
		FullBox(x)
	}

	F tr(x:Eachable, pa:PatternAction, tc:TrContext, my_each:Fun, my_result:Fun) {

		if (=~)(x, pa.pattern, tc) {
			return pa::action(x, tc).FullBox()
		}

		t = typeof(x)
		ret = t()  # XXX: Assumption about existence of the constructor
		tc.deeper({
			x.my_each(F(idx_or_key, val) {
				t = tr(val, pa, tc.set_last_path_element(idx_or_key))
				ematch t {
					FullBox my_result(ret, idx_or_key, t.get())
					EmptyBox null # do nothing
				}
			})
		})
		FullBox(ret)
	}

	F tr(x:Eachable1, pa:PatternAction, tc:TrContext) {
		guard x !~ AnyOf(Int, Str)
		tr(x, pa, tc, each_idx_val, F(ret, idx, val) ret.push(val))
	}

	F tr(x:Eachable2, pa:PatternAction, tc:TrContext) {
		tr(x, pa, tc, each, F(ret, key, val) ret[key] = val)
	}


	F tr(x, transformation) {
		tc = TrContext().set(_root=x, transformation=transformation)
		result = tr(x, transformation, tc)
		assert(result, FullBox, "Transformation failed, top level must return a value")
		result.get()
	}

	TEST [1,2,3].tr(Int -> (X+1)) == [2,3,4]
	TEST {"a": [1,2,3]}.tr(Int -> (X+1)) == {"a": [2,3,4]}

}