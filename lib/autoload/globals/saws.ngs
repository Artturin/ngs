# experimental Semantic AWS library

ns {
	global init, Str, JsonData

	type Source
	F init(s:Source, repo:Str, branch:Str) init(args())
	F Str(s:Source) "${s.repo}@${s.branch}"
	F JsonData(s:Source) s.Hash().JsonData()

	# TODO
	# type Action
	# F init(a:Action, stage_name:Str, action_name: Str) init(args())
	# F Str(a:Action) ...

	F pipes() {
		# List of AWS::CodePipeline::Pipeline
		pipelines = ``aws codepipeline list-pipelines``
		pipelines.pmap(2, F(p) {
			e = ``aws codepipeline list-pipeline-executions --pipeline-name ${p.name} --max-results 1``
			e = e.get('pipelineExecutionSummaries', []).get(0, {})
			# echo(e)

			if e {
				# TODO: show if it's stuck on manual approval
				# details = ``aws codepipeline get-pipeline-execution --pipeline-name ${p.name} --pipeline-execution-id ${e.pipelineExecutionId}``
				# echo(details)
				pipeline = ``aws codepipeline get-pipeline --name ${p.name}``
				state = ``aws codepipeline get-pipeline-state --name ${p.name}``

				section "approvals" {
					approval_actions = collector
						pipeline.pipeline.stages.each(F(stage) {
							stage.actions.filter({'actionTypeId': {'category': 'Approval', 'provider': 'Manual'}}).each(F(action) {
								collect([stage.name, action.name])
							})
						})
					approval_actions.each(F(a) {
						m = state =~ Has({
							"latestExecution": {
								"pipelineExecutionId": e.pipelineExecutionId
							}
							"actionStates": Has({"actionName": a[1]} -> {a.push(A.latestExecution.status)} )
							"stageName": a[0]
						})
						if not(m) {
							a.push('ahead')
						}
					})

					approval_actions .= map({ "${A[0]} -> ${A[1]}: ${A[2]}" })  # XXX: semantics mixed with representation
				}

				section "sources" {
					sources = collector
						pipeline.pipeline.stages.each(F(stage) {
							stage.actions.filter({'actionTypeId': {'category': 'Source', 'provider': 'CodeStarSourceConnection'}}).each(F(action) {
								# collect([action.configuration.FullRepositoryId, action.configuration.BranchName])
								collect(Source(action.configuration.FullRepositoryId, action.configuration.BranchName))
							})
						})
					# sources .= map({ "${A[0]}@${A[1]}" })  # XXX: semantics mixed with representation
				}

			} else {
				approval_actions = []
				sources = []
			}

			# echo(e)
			{
				'name': p.name
				'status': e.status
				'sources': sources
				'revisions': e.sourceRevisions.map(F(r) {
					# TODO: semantically correct data structure, not just form string for output
					"${r.actionName}: ${r.revisionId.limit(8)} ${r.revisionSummary.decode_json().CommitMessage.limit(30).replace('\n', ' ')}"
				})
				'last_executed': e.lastUpdateTime
				'approvals': approval_actions
			}
		})
	}

}


