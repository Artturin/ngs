# experimental Semantic AWS library

ns {
	global init, Str, JsonData

	# Poorly named hack for UI
	type SendAllFields

	# TODO: consider showing sources and revisions together

	# TODO: ensure alignment with AWS output
	type Source(SendAllFields)
	F init(s:Source, repo:Str, branch:Str) init(args())
	F Str(s:Source) "${s.repo}@${s.branch}"
	F JsonData(s:Source) s.Hash().JsonData()

	# TODO: ensure alignment with AWS output
	type Action(SendAllFields)
	F init(a:Action, stage_name:Str, action_name:Str, status:Str) init(args())
	F Str(a:Action) "${a.stage_name}/${a.action_name}: ${a.status}"
	F JsonData(a:Action) a.Hash().JsonData()

	# TODO: ensure alignment with AWS output
	type Revision(SendAllFields)
	F init(r:Revision, action_name:Str, id:Str, message:Str) init(args())
	F Str(r:Revision) "${r.action_name}: ${r.id.limit(8)} ${r.message.limit(30).replace('\n', ' ')}"
	F JsonData(r:Revision) r.Hash().JsonData()

	# TODO: "not applicable or unknown" subtype
	# TODO: "N out of M" subtype (that's what current Progress is)
	type Progress(SendAllFields)
	F init(p:Progress, step:Int, total_steps:Int) init(args())
	F Str(p:Progress) "${p.step}/${p.total_steps}"
	F JsonData(p:Progress) p.Hash().JsonData()

	type LongValue(SendAllFields)
	F init(lv:LongValue, val) init(args())
	F Str(lv:LongValue) lv.val.Arr().digest(4).join('')
	F JsonData(lv:LongValue) lv.val.JsonData()


	F pipes() {
		# List of AWS::CodePipeline::Pipeline
		pipelines = ``aws codepipeline list-pipelines``
		pipelines.pmap(2, F(p) {
			e = ``aws codepipeline list-pipeline-executions --pipeline-name ${p.name} --max-results 1``.get(0, {})

			# TODO: eliminate e.attr references outside this if
			if e {
				pipeline = ``aws codepipeline get-pipeline --name ${p.name}``
				state = ``aws codepipeline get-pipeline-state --name ${p.name}``

				section "approvals" {
					approval_actions = collector {
						pipeline.stages.each(F(stage) {
							stage.actions.filter({'actionTypeId': {'category': 'Approval', 'provider': 'Manual'}}).each(F(action) {
								status = 'ahead'
								state =~ Has({
									"latestExecution": {
										"pipelineExecutionId": e.pipelineExecutionId
									}
									"stageName": stage.name
									"actionStates": Has({"actionName": action.name} -> { status = A.latestExecution.status })
								})
								collect(Action(stage.name, action.name, status))
							})
						})
					}
				}
			} else {
				approval_actions = []
			}

			section "sources" {
				sources = collector {
					pipeline.stages.each(F(stage) {
						stage.actions.filter({'actionTypeId': {'category': 'Source', 'provider': 'CodeStarSourceConnection'}}).each(F(action) {
							collect(Source(action.configuration.FullRepositoryId, action.configuration.BranchName))
						})
					})
				}
			}

			section "progress" {
				# TODO
				total_actions = pipeline.stages.actions.flatten().len()

				# TODO: make sure that not matching Repeat(HERE) does not affect the counting
				statuses = collector/Stats() {
					state =~ Repeat({
						"latestExecution": {
							"pipelineExecutionId": e.pipelineExecutionId
						}
						"actionStates": Repeat({"latestExecution": {"status": collect}})
					})
				}
			}


			{
				'name': p.name
				'status': e.status
				'sources': sources
				'revisions': e.sourceRevisions.map(F(r) Revision(r.actionName, r.revisionId, r.revisionSummary.CommitMessage))
				'last_executed': e.lastUpdateTime
				'approvals': approval_actions
				'progress': if statuses { Progress(statuses.Succeeded, total_actions) }
			}
		})
	}

	F stacks() {
		``aws cloudformation describe-stacks``::{
			A.each_idx_val(F(i, stack) {
				# TODO: something more elegant here
				A[i] = stack.mapkv({
					A =~ 'StackName' returns [A, B]
					B =~ AllOf(Str, AnyOf(Pfx('arn'), {A.len() > 20})) returns [A, LongValue(B)]
					[A, B]
				})
			})

		}
	}

}


