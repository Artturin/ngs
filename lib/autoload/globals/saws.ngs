# experimental Semantic AWS library

ns {
	global init, Str, JsonData

	# TODO: ensure alignment with AWS output
	type Source
	F init(s:Source, repo:Str, branch:Str) init(args())
	F Str(s:Source) "${s.repo}@${s.branch}"
	F JsonData(s:Source) s.Hash().JsonData()

	# TODO: ensure alignment with AWS output
	type Action
	F init(a:Action, stage_name:Str, action_name:Str, status:Str) init(args())
	F Str(a:Action) "${a.stage_name}/${a.action_name}: ${a.status}"
	F JsonData(a:Action) a.Hash().JsonData()

	F pipes() {
		# List of AWS::CodePipeline::Pipeline
		pipelines = ``aws codepipeline list-pipelines``
		pipelines.pmap(2, F(p) {
			e = ``aws codepipeline list-pipeline-executions --pipeline-name ${p.name} --max-results 1``
			e = e.get('pipelineExecutionSummaries', []).get(0, {})
			# echo(e)

			if e {
				pipeline = ``aws codepipeline get-pipeline --name ${p.name}``
				state = ``aws codepipeline get-pipeline-state --name ${p.name}``

				section "approvals" {
					approval_actions = collector
						pipeline.pipeline.stages.each(F(stage) {
							stage.actions.filter({'actionTypeId': {'category': 'Approval', 'provider': 'Manual'}}).each(F(action) {
								status = 'ahead'
								state =~ Has({
									"latestExecution": {
										"pipelineExecutionId": e.pipelineExecutionId
									}
									"stageName": stage.name
									"actionStates": Has({"actionName": action.name} -> { status = A.latestExecution.status })
								})

								collect(Action(stage.name, action.name, status))
							})
						})
				}

				section "sources" {
					sources = collector
						pipeline.pipeline.stages.each(F(stage) {
							stage.actions.filter({'actionTypeId': {'category': 'Source', 'provider': 'CodeStarSourceConnection'}}).each(F(action) {
								collect(Source(action.configuration.FullRepositoryId, action.configuration.BranchName))
							})
						})
				}

			} else {
				approval_actions = []
				sources = []
			}

			# echo(e)
			{
				'name': p.name
				'status': e.status
				'sources': sources
				'revisions': e.sourceRevisions.map(F(r) {
					# TODO: semantically correct data structure, not just form string for output
					"${r.actionName}: ${r.revisionId.limit(8)} ${r.revisionSummary.decode_json().CommitMessage.limit(30).replace('\n', ' ')}"
				})
				'last_executed': e.lastUpdateTime
				'approvals': approval_actions
			}
		})
	}

}


