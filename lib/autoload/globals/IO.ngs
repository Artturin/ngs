ns {

	# Events for COR filters
	events = ns {
		global init
		type Read(COR::IncomingEvent)
		F init(r:Read, data) {
			r.data = data
		}

		type Write(COR::OutgoingEvent)
		F init(w:Write, data) {
			w.data = data
		}

		type Active(COR::IncomingEvent)
		type Inactive(COR::IncomingEvent)
	}

	# COR filters
	handlers = ns {
		global init, handle
		type Splitter(COR::Handler)
		F init(s:Splitter, sep:Str) {
			s.sep = sep
			s.buf = ''
		}

		F handle(s:Splitter, hc:COR::HandlerContext, r:events::Read) {
			debug('IO', "handle(IO::handlers::Splitter,...,Read) got data of len ${r.data.len()}")

			s.buf += r.data
			while true {
				# TODO: start the search from previous position
				# TODO: handle "\r\n"
				p = pos(s.buf, "\n")
				p == null breaks
				line = s.buf[0..p]
				s.buf = s.buf[(p+1)..null]
				# echo("LINE $line")
				hc.fire(events::Read(line))
			}
		}

		F handle(s:Splitter, hc:COR::HandlerContext, i:events::Inactive) {
			if s.buf {
				debug('IO', "handle(IO::handlers::Splitter,...,Inactive) passing leftover of len ${s.buf.len()}")
				hc.fire(events::Read(s.buf))
			}
			hc.fire(i)
		}


		section "JSON-RPC Handler" {

			_VALID_JSON_RPC_REQUEST = {
				'jsonrpc': '2.0'
				'method': Str
				'id': IfExists(AnyOf(Num, Str, Null))
				'params': IfExists(AnyOf(Arr, Hash))
			}

			# https://www.jsonrpc.org/specification
			type JsonRpc(COR::Handler)

			F init(jrh:JsonRpc) throw InvalidArgument("JsonRpc() was called without arguments")

			F init(jrh:JsonRpc, methods:Namespace) init(args())

			F handle(jrh:JsonRpc, hc:COR::HandlerContext, r:events::Read) block b {
				data = r.data
				debug('server', "JsonRpc Read")

				F send_error(code, message, data=null) {
					error("JsonRpc on_data send_error -- ${code} ${message} ${data}")
					ret = {
						'jsonrpc': '2.0'
						'id': req.get('id')
						'error': {
							'code': code
							'message': message
							'data': data
						}.filterv()
					}
					hc.fire(events::Write(ret.encode_json() + "\n"))
					b.return()
				}

				req = {}  # allow send_error() to do req.get('id') if we crash in try
				req = try {
					data.decode_json()
				} catch(e:JsonDecodeFail) {
					send_error(-32700, 'Parse error', e.Hash().filterk(AnyOf('error', 'value', 'position')))
				}

				if (req !~ _VALID_JSON_RPC_REQUEST) send_error(-32600, 'Invalid Request', 'See https://www.jsonrpc.org/specification')

				if (req.method not in jrh.methods) send_error(-32601, 'Method not found', "Method ${req.method} not found. Available methods: ${jrh.methods.keys()}")

				args = []
				kwargs = {}
				if 'params' in req {
					match req.params {
						Arr args = req.params
						Hash kwargs = req.params
					}
				}

				debug('server', "JsonRpc on_data -- invoking ${req.method}")
				result = try {
					jrh.methods[req.method](*args, **kwargs)
				} catch(mnf:MethodNotFound) {
					guard mnf.callable === jrh.methods[req.method]
					send_error(-32602, 'Invalid params', "Correct parameters can be seen in methods' descriptions: ${jrh.methods[req.method].Arr()}")
				} catch(e:Error) {
					send_error(-32603, 'Internal error', e.Str())
				}

				if 'id' in req {
					# response expected
					ret = {
						'jsonrpc': '2.0'
						'id': req.id
						'result': result
					}.filterv() # Why filterv()?
					debug('server', 'JsonRpc on_data -- sending reply')
					hc.fire(events::Write(ret.encode_json() + "\n"))
				}

			} # handle Read

		} # "JSON-RPC handler"


	} # ns handlers

}