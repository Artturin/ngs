ns {

	section "Wrappers around C functions" {
		F _assert(code:Int, func:Str) {
			e = c_errno()
			if code == -1 {
				c_errno() throws CError(e, "${func}() failed")
				throw InvalidArgument("C code returned -1 but errno is not set")
			}
			code
		}

		global socket
		F socket(domain:Int, type:Int, protocol:Int=0) c_socket(domain, type, protocol)._assert('socket').assert(X>0)

		global bind
		F bind(socket:Int, address:c_sockaddr) c_bind(socket, address)._assert('bind').assert(0)

		TEST socket(C_PF_UNIX, C_SOCK_DGRAM) >= 0
		TEST $(ok:[0, 1] rm sock_test); bind(socket(C_PF_UNIX, C_SOCK_DGRAM), c_sockaddr_un("sock_test")) == 0

		global recvfrom
		F recvfrom(sock:Int, length:Int, flags:Int, address:c_sockaddr) {
			ret = c_recvfrom(sock, length, flags, address)
			ret[0]._assert('recvfrom')
			ret[1]
		}

		global listen
		F listen(sock:Int, backlog:Int) c_listen(sock, backlog)._assert('listen')

		global accept
		F accept(sock:Int, address:c_sockaddr) c_accept(sock, address)._assert('accept')

		global send
		F send(socket: Int, buffer:Str, flags:Int=0) c_send(socket, buffer, flags)._assert('send')
	}

	section "Higher level networking" {

		type Server
		type ThreadedServer(Server)
		type ThreadedUnixServer(ThreadedServer)
		type Connection

		global init

		F init(c:Connection, server:Server, sock:Int) {
			c.server = server
			c.sock = sock
			# For user data
			c.user = {}
		}

		global close
		F close(c:Connection) c.sock.close()
		F send(c:Connection, data:Str) c.sock.send(data)

		F listen(tus:ThreadedUnixServer, path:Str, on_connect=nop, on_data=nop) {
			sock = socket(C_PF_UNIX, C_SOCK_STREAM)
			tus.sock = sock
			debug('server', "Sock: ${sock}")
			$(ok:[0, 1] rm $path)
			bind(sock, c_sockaddr_un(path))
			remote_addr = c_sockaddr_un()
			listen(sock, 5)
			while true {
				accepted = accept(sock, remote_addr)
				debug('server', "Connection socket: ${accepted}")
				c = Connection(tus, accepted)
				# TODO: join the thread / use Executor
				Thread("connection-${accepted}", {
					on_connect(c)
					while true {
						data = recvfrom(c.sock, 1024, 0, c_sockaddr_un())
						data == '' breaks
						debug('server', "Data: ${data.SafeStr().limit(1024)}")
						# c.send("[${c.sock}] Echoing back: ${data}")
						on_data(c, data)
					}
					close(c)
				})
			}
		}

		F test_un_server() {
			F on_connect(c:Connection) {
				log("Connection ${c}")
			}
			F on_data(c:Connection, data:Str) {
				c.send("[${c.sock}] Echoing back: ${data}")
			}
			net::ThreadedUnixServer().listen("sock_test", on_connect=on_connect, on_data=on_data)
		}

		# DEBUG=server ngs -pi 'net::test_un_server()'
		# echo wwwxyz | nc -U build/sock_test
	}
}

