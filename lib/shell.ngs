# WIP
# XXX: Ugly hack to prevent direct output to stdout.
F '$()'(cp:CommandsPipeline) {
	cp.options .= without('top_level')
	if cp.options.get('x_top_level') {
		cp.options.top_level = cp.options.x_top_level
	}
	guard false
}

WEB_SERVER_DIR = Dir(".." / "ngs-web-ui").assert()
ENV.BROWSER = 'none'
web_server = $(cd:WEB_SERVER_DIR npm start &)
echo("Web server PID: ${web_server.processes[0].pid}")

PROXY_DIR = Dir(".." / "ngs-web-ui-proxy").assert()

# Hack - names, because parameters' types can only be identifiers
ServerHandler = net::ServerHandler
Server = net::Server
# Hack - on_listen() can happen for any ServerHandler, not necessarily the one used below.
F on_listen(sh:ServerHandler, s:Server) {
	super(sh, s)
	p = $(x_top_level:: cd:PROXY_DIR npx ts-node src/server.ts ../ngs/ngs-shell.sock &)
	echo("Proxy PID: ${p.processes[0].pid}")
	# TODO: open the web app
}

{ ui }

net::unix_json_rpc_server("ngs-shell.sock", ns {

	F eval(line:Str) {

		F transform(x) x

		F transform(a:Arr) {
        	guard a
        	guard all(a, Hash)
        	Table2::Table(a)
        }

		# TODO: find better place for this
		# Based on: F ````(cp:CommandsPipeline)
        F transform(pp:ProcessesPipeline) {
			processes = pp.processes
			guard processes
			p = processes[-1]
			r = Result({ p.stdout.decode({'process': p}) })
			if r is Failure {
				error("In shell.ngs, trying to decode:")
				print_exception(r.val)
			}
			guard r
			decoded = r.get()
			if p =~ %(aws codepipeline list-pipelines) {
				for pipeline in decoded {
					pipeline.name = ui::InteractiveObject().set(
						type = 'AWS::CodePipeline::Pipeline'
						id = pipeline.name
						text = pipeline.name
						default_action = 'View CodePipeline'
					)
				}
			}
			decoded.transform()
        }


		fname = '<shell line file>'

		section "Frequent testing assist" {
			_assist = {
				'v': 'aws ec2 describe-vpcs'
				'p-': 'aws codepipeline list-pipelines'
				'p': '{ require("aws/CodePipeline.ngs")::pipelines::list() }'
				's-': 'aws cloudformation list-stacks'
				's': 'saws::stacks()'
			}
			line = _assist.get(line, line)
		}
		bytecode = compile(line, fname)
		# TODO: pass warnings
		#bytecode.meta().warnings.each(F(w) {
		#	wl = w.location
		#	warn("${fname}:${wl.first_line}:${wl.first_column} warning: ${w.message}")
		#})

		func = load(bytecode, "<shell line func>")
		result = func()
		log("Result type ${result.Type().name}")
		result .= transform()
		log("Result type after transform() ${result.Type().name}")
		result = ui::JsonData(result)
	}

	section "tests" {

		F test() {
			"test method active"
		}

		F test_add_one(n:Int) {
			n + 1
		}

		F test_div_by_zero() {
			1 / 0
		}
	}

	doc TODO - plugins fan-out / plugins register to serve
	F ui_default_action(type, id) {
		debug("ui_default_action on object ${type} ${id} was not handled")
	}

	doc Unusable output
	F ui_default_action(type, id) {
		guard type == 'AWS::CodePipeline::Pipeline'
		log('ui_default_action for AWS::CodePipeline::Pipeline')
		# TODO: escape_bash() version of the command too
		# TODO: deduplicate the command
		ui::JsonData({
			'type': 'timeline_new_command'
			'command': %[aws codepipeline get-pipeline --name $id]
			'output': ``aws codepipeline get-pipeline --name $id``
		})
	}

})
