#!/usr/bin/env ngs
ns(global_inspect=inspect) {

	# WIP
	# Ngs Amazon Swiss army Knife
	# This is an experiment towards creating the shell UI.

	Timeline  # autoload TimelineStatus
	type PipelineExecution(HashLike)
	type PipelineActionExecution(HashLike)

	F watch() {
		log("Starting to watch AWS profile ${profile}")
		while true {
			inspect()
			sleep(30)
		}
	}

	F horizon() {
		seconds = ENV.get('HORIZON', '3600').Int()
		Time(Time().Int() - seconds)
	}

	F inspect() {
		log("Looking up stacks")
		stacks = AWS2::regions(%(aws cloudformation describe-stacks))
		log("Stacks found in regions: ${stacks._Region.sort().Stats()}")

		log("Listing regions with codepipeline service")
		pipelines_regions = ``aws ssm get-parameters-by-path --path /aws/service/global-infrastructure/services/codepipeline/regions``.Value
		pipelines_regions .= filter(AnyOf(AWS2::regions()))  # Intersection of regions we are in and where the service is available
		# log("Pipelines are supported in regions: ${pipelines_regions}")

		log("Looking up pipelines")
		pipelines = AWS2::regions(%(aws codepipeline list-pipelines), pipelines_regions)
		log("Pipelines found in regions: ${pipelines._Region.sort().Stats()}")

		# pipelines.pmap(4, inspect_pipeline)
		inspect_pipeline(pipelines[0])

		# TODO: AMIs creation
	}

	global Timeline
	F Timeline(pe:PipelineExecution) {

		# pe.status: InProgress, Stopped, Stopping, Succeeded, Superseded, Failed - https://awscli.amazonaws.com/v2/documentation/api/latest/reference/codepipeline/list-pipeline-executions.html
		s = TimelineStatus
		status_translation = {
			'InProgress': s::Running()
			'Stopped': s::Cancelled()
			'Stopping': s::Stopping()
			'Succeeded': s::Succeeded()
			'Superseded': s::Cancelled()
			'Failed': s::Failed()
		}

		Timeline()::{
			A.time_start = pe.startTime
			A.time_last_update = pe.lastUpdateTime
			A.data = pe
			A.status = status_translation[pe.status]
			if A.status =~ Not(s::Running) {
				A.time_end = pe.lastUpdateTime
			}
		}
	}

	F augment(pe:PipelineExecution) {
		log("Not augmenting PipelineExecution ${pe.pipelineExecutionId}")
	}

	F augment(pe:PipelineExecution) {
		guard pe.status == 'Failed'
		log("Augmenting failed PipelineExecution ${pe.pipelineExecutionId}")
		actionExecutionDetails = ``aws codepipeline list-action-executions --pipeline-name ${pe._Name} --filter "pipelineExecutionId=${pe.pipelineExecutionId}" --region ${pe._Region}``
		echo(actionExecutionDetails.global_inspect())
	}


	# TODO: AWS types such as CodePipeline
	F inspect_pipeline(pipeline:Hash) {
		assert(pipeline, {'name': Str, 'version': Int, 'created': Str, 'updated': Str, '_Region': Str})

		pipelineExecutionSummaries = ``aws codepipeline list-pipeline-executions --pipeline-name ${pipeline.name} --region ${pipeline._Region}``
		pipelineExecutionSummaries._Region = ConstIter(pipeline._Region)
		pipelineExecutionSummaries._Name = ConstIter(pipeline.name)
		pipelineExecutionSummaries .= map(PipelineExecution)

		# lastUpdateTime pipelineExecutionId sourceRevisions startTime status trigger _Region
		pipelineExecutionSummaries.map(F(s) {
			s.startTime .= Time()
			s.lastUpdateTime .= Time()
			augment(s)
			Timeline(s)::{
				A.name = "Pipeline Execution ${s.pipelineExecutionId} (${s.status})"
			}
		}).filter(F(ti) ti.Time() > horizon()).Timeline().set(name="Pipeline ${pipeline.name} after ${horizon()}")
	}

	F inspect_pipeline(name:Str) {
		``aws codepipeline list-pipelines``.the_one({'name': name}).set(_Region=`line: aws configure get region`).inspect_pipeline()
	}

}